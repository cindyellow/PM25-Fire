---
title: "Week 8: Merging with AQS Part 2, Getting Cluster Information" 
subtitle: "SURA 2022"
author: "Shih-Ting (Cindy) Huang"
date: '2022-07-29'
output: html_document
---

```{r setup, message=FALSE, warning=FALSE, echo=FALSE, include=FALSE}
knitr::opts_chunk$set(message=FALSE, warning=FALSE, echo=FALSE)

library(tidyverse)
library(dplyr)
library(sf)
library(mapview)
library(RColorBrewer)
library(dbscan)
library(fpc)
library(lwgeom)
library(concaveman)
```

```{r load-data, echo=FALSE, include=FALSE}
# Run the script to preprocess fire datasets to include information on time, location, and FRP
# This will limit our observations to those in California
# Object created: "fire", "in_cali" datasets
url1 <- "https://raw.githubusercontent.com/cindyellow/SURA-2022/main/preprocess_fire_txt.R"
if (!file.exists("../preprocess_fire_txt.R"))
  download.file(url1, destfile = "../preprocess_fire_txt.R")
source("../preprocess_fire_txt.R")

# Run the script to preprocess smoke dataset, including additional information on smoke area
# Object created: "smoke" dataset
url2 <- "https://raw.githubusercontent.com/cindyellow/SURA-2022/main/preprocess_smoke_kml.R"
if (!file.exists("../preprocess_smoke_kml.R"))
  download.file(url2, destfile = "../preprocess_smoke_kml.R")
source("../preprocess_smoke_kml.R")
```


## HDBSCAN: Assigning representative points for each cluster

```{r}
# Function for finding best minpts for a day and building clusters based on that
build_best_cl <- function(day){
  coords <- as.tibble(st_coordinates(day$geometry))
  scores <- c()
  for (x in minpts){
    cl <- hdbscan(coords, minPts = x)
    # check if there are cluster scores available
    if (all(is.na(cl$cluster_scores))){
      scores <- c(scores, 0)
    } else{
      scores <- c(scores, cdbw(coords, cl$cluster)$cdbw)
    }
  }
  
  best_param <- minpts[which.max(scores)]
  return (hdbscan(coords, minPts=best_param))
}
```

```{r}
# Function to get a dataframe of each cluster's polygon, area, FRP summaries, and number of points for a day
get_cluster_info <- function(cl, day){
  # Assign cluster to all observations 
  day <- day %>%
    mutate(cluster = paste0(date, "_", cl$cluster)) %>%
    filter(cluster != paste0(date, "_", "0"))
  
  # Create polygon and FRP summaries for each cluster
  day_cl <- day %>%
    group_by(cluster) %>%
    group_modify(function(x,y) bind_rows(tibble(polygon = concaveman(x)$polygons,
                                              area = round(st_area(polygon), 3),
                                              frp_avg = round(mean(x$frp, na.rm=TRUE),4),
                                              frp_vars = round(var(x$frp, na.rm=TRUE),4),
                                              num_pts = count(x)$n)))
  return (day_cl)
}
```

For this function, there may be warnings that read `Although coordinates are longitude/latitude, it is assumed that they are planar.` This warning is acceptable since we're looking at a small local region for calculating area. More about it [here](https://github.com/r-spatial/sf/issues/493)

```{r}
# Function for getting k representative points for a day
get_rep_pts <- function(cl, day, cluster_info, k){
  reps <- day %>%
    # Get membership probability for each observation
    mutate(cluster = paste0(date, "_", cl$cluster), mem_prob = cl$membership_prob) %>%
    arrange(desc(mem_prob)) %>%
    group_by(cluster) %>%
    # Filter by distinct locations
    distinct(geometry, .keep_all=TRUE) %>%
    # Get the top k most probable observations for each cluster
    slice(1:k) %>%
    # Append with cluster information to get complete info
    inner_join(cluster_info, by="cluster")
  return(reps)
}
```

```{r, warning=FALSE, message=FALSE}
# Get representative points and cluster information for all dates within range
minpts <- seq(5,100,by=5)

# Dataframes for storing all the info
rep_pts <- c()
cluster_info <- c()

dates <- seq(as.Date("2018-11-08"), as.Date("2018-11-16"), by=1)

for (d in as.list(dates)){
  day <- in_cali %>%
    st_as_sf(coords = c("longitude", "latitude"), crs = 4326, remove=FALSE) %>%
    st_set_crs(4326) %>%
    filter(date == d)
  
  cl <- build_best_cl(day)
  ci <- get_cluster_info(cl,day)
  reps <- get_rep_pts(cl, day, ci, 1)
  cluster_info <- rbind(cluster_info, ci)
  rep_pts <- rbind(rep_pts, reps)
}
```


## Merging with AQS data

```{r}
# Read AQS data and restrict to campfire week
aqs <- read.delim("../data/AQS_PM25_2000_2021_Cali.csv", sep=",", strip.white=TRUE)
aqs <- aqs %>%
  filter(Date > "2018-11-07" & Date < "2018-11-17")

# Create geometry object for coordinates (used for sf calculations)
aqs <- aqs %>%
  st_as_sf(coords = c("Longitude", "Latitude"), crs = 4326, remove=FALSE) %>%
  st_set_crs(4326)
```

```{r}
# Convert dataframes to sf objects
rep_pts_sf <- st_as_sf(rep_pts)
smoke <- st_as_sf(smoke)
```


## Smoke Indicator Variables & Distance to Closest Fire

```{r}
#Filter by date for all dfs
dates <- seq(as.Date("2018-11-08"), as.Date("2018-11-16"), by=1)

# Set default values for smoke indicator variables
aqs <- aqs %>%
  mutate(light=NA, med=NA, heavy=NA,fire_dist=NA,closest_cl=NA)

for (d in as.list(dates)){
  day_smoke <- smoke %>%
    filter(format(start_time, format="%Y-%m-%d") == d)
  day_aqs <- aqs %>%
    dplyr::select(c("PM25", "Date", "Latitude", "Longitude")) %>%
    filter(Date == d)
  day_fire <- rep_pts_sf %>%
    filter(date == d)
  
  # Get closest cluster & distance
  closest_fire <- st_nearest_feature(day_aqs, day_fire)
  day_aqs$fire_dist <- st_distance(day_aqs$geometry, day_fire[closest_fire,], by_element=TRUE)
  day_aqs$closest_cl <- day_aqs$closest_cl <- day_fire[closest_fire,]$cluster
  
  # Get indicator variables
  smoke_regions <- st_intersects(day_aqs$geometry, day_smoke$geometry)
  day_aqs$light <- lapply(smoke_regions, function(x)ifelse('light' %in% unique(day_smoke[unlist(x),]$type), 1, 0))
  day_aqs$med <- lapply(smoke_regions, function(x)ifelse('medium' %in% unique(day_smoke[unlist(x),]$type), 1, 0))
  day_aqs$heavy <- lapply(smoke_regions, function(x)ifelse('heavy' %in% unique(day_smoke[unlist(x),]$type), 1, 0))
  day_aqs <- as.tibble(day_aqs) %>%
    dplyr::select(-geometry) %>%
    mutate(across(c("light", "med", "heavy"), as.double))
  
  # Clean up everything
  aqs <- aqs %>%
    left_join(as.tibble(day_aqs), by=c("PM25", "Date", "Latitude", "Longitude")) %>%
    mutate(light = coalesce(light.y, light.x),
           med = coalesce(med.y, med.x),
           heavy = coalesce(heavy.y, heavy.x),
           fire_dist = coalesce(fire_dist.y, fire_dist.x),
           closest_cl = coalesce(closest_cl.y, closest_cl.x)) %>% 
    dplyr::select(-light.x, -light.y, -med.x, -med.y, -heavy.x, -heavy.y, -fire_dist.x, -fire_dist.y, -closest_cl.x, -closest_cl.y)
}

```

### Doublecheck

We doublecheck that all the closest clusters are assigned correctly with respect to date.

```{r}
match <- aqs$Date == as.Date(gsub("_[0-9][0-9]*", "", aqs$closest_cl))
sum(is.na(match) | match == FALSE)
```


## Cluster Polygons
References: 
- [Creating polygons](https://stackoverflow.com/questions/53440909/polygon-from-cluster-of-lat-long-points-in-r)

In the previous section calculating representative points, I have added each cluster's polygon object as well, storing the information in a dataframe called `cluster_info`. Let's plot it out and see what a sample polygon looks like.

### Plot on Map

```{r}
ci_sf <- cluster_info %>%
  mutate(density = num_pts/area, date = as.Date(gsub("_[0-9][0-9]*", "", cluster))) %>%
  filter(date == "2018-11-08") %>%
  st_as_sf()

nov_8 <- in_cali %>%
    filter(date == "2018-11-08")

mapview(ci_sf, zcol="cluster", label=FALSE, layer.name = 'Cluster',
        popup = popupTable(
                ci_sf,
                zcol = c(
                  "cluster",
                  "area",
                  "density",
                  "frp_avg",
                  "frp_vars",
                  "num_pts"
                  ),
                feature.id = FALSE
                )         
        ) + 
  mapview(nov_8, cex=5, label=FALSE, legend=FALSE)
```









